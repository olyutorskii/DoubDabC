<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BcdRegister.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">DoubDabC</a> &gt; <a href="index.source.html" class="el_package">io.github.olyutorskii.doubdabc</a> &gt; <span class="el_source">BcdRegister.java</span></div><h1>BcdRegister.java</h1><pre class="source lang-java linenums">/*
 * License : The MIT License
 * Copyright(c) 2017 olyutorskii
 */

package io.github.olyutorskii.doubdabc;

/**
 * BCD register with Double-Dabble algorithm operation.
 *
 * &lt;p&gt;BCD register is flexible pseudo register of you specified size.
 * BCD register is layouted on int array.
 *
 * &lt;p&gt;Each decimal columns are layouted 4bit nibble width on BCD register.
 * &lt;ul&gt;
 * &lt;li&gt;Lower decimal digit is layouted on lower int bits.
 * &lt;li&gt;Lower decimal digit is layouted on younger int array element.
 * &lt;/ul&gt;
 *
 * &lt;p&gt;There is 1bit binary input stream from LSB.
 *
 * &lt;p&gt;Each decimal digit overlaps Packed-BCD and Bi-quinary coded decimal.
 *
 * &lt;p&gt;Signed(negative) decimal value is not supported.
 *
 * @see &lt;a target=&quot;_blank&quot;
 * href=&quot;https://en.wikipedia.org/wiki/Double_dabble&quot;&gt;
 * Double dabble (Wikipedia)
 * &lt;/a&gt;
 * @see &lt;a target=&quot;_blank&quot;
 * href=&quot;https://en.wikipedia.org/wiki/Binary-coded_decimal&quot;&gt;
 * Binary-coded decimal (Wikipedia)
 * &lt;/a&gt;
 * @see &lt;a target=&quot;_blank&quot;
 * href=&quot;https://en.wikipedia.org/wiki/Bi-quinary_coded_decimal&quot;&gt;
 * Bi-quinary coded decimal (Wikipedia)
 * &lt;/a&gt;
 */
<span class="pc bpc" id="L39" title="1 of 2 branches missed.">public class BcdRegister {</span>

    /**
     * Max decimal digits for unsigned int32.
     *
     * &lt;p&gt;(&amp;quot;4294967295&amp;quot;.length)
     */
    public static final int MAX_COL_UINT32 = 10;

    /**
     * Max decimal digits for unsigned int64.
     *
     * &lt;p&gt;(&amp;quot;18446744073709551615&amp;quot;.length)
     */
    public static final int MAX_COL_UINT64 = 20;


    private static final int PRIM_BITSIZE = Integer.SIZE;
    private static final int PRIM_SLOTS =
            PRIM_BITSIZE / BcdUtils.BCD_BITSIZE;

    private static final int LSB_PRIMMASK = 0b1;
    private static final int MSB_PRIMMASK = 0b1 &lt;&lt; (PRIM_BITSIZE - 1);
    private static final int NIBBLE_MASK  = // 0b1111
            (0b1 &lt;&lt; BcdUtils.BCD_BITSIZE) - 1;

    private static final int PRIMIDX_SHIFT = 3;    //  [ /  8]  [&gt;&gt;&gt; 3]
    private static final int NBLIDX_MASK =         //  [mod 8]  [&amp; 0b111]
            (0b1 &lt;&lt; PRIMIDX_SHIFT) - 1;

    private static final char SP = '\u0020';
    private static final char CH_OPEN = '[';
    private static final char CH_CLOSE = ']';

<span class="fc" id="L73">    private static final char[] HEXCH_TBL = {</span>
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
        'A', 'B', 'C', 'D', 'E', 'F',
    };

    static{
        assert 0b1 &lt;&lt; PRIMIDX_SHIFT == PRIM_SLOTS;
        assert (-1 &amp; NBLIDX_MASK) == PRIM_SLOTS - 1;
<span class="pc bpc" id="L81" title="2 of 4 branches missed.">        assert HEXCH_TBL.length == 0b1 &lt;&lt; BcdUtils.BCD_BITSIZE;</span>
<span class="fc" id="L82">    }</span>


    private final int maxDigits;
    private final int[] ibuf;

    private int precision;    // negative value if unknown.


    /**
     * Constructor.
     *
     * &lt;p&gt;Decimal digits are round-uped to int array fitting size.
     *
     * @param maxDigits decimal digits to store result.
     * @throws IllegalArgumentException not positive digits.
     */
    public BcdRegister(int maxDigits) throws IllegalArgumentException{
<span class="fc" id="L100">        super();</span>

<span class="fc bfc" id="L102" title="All 2 branches covered.">        if(maxDigits &lt;= 0) throw new IllegalArgumentException();</span>

<span class="fc" id="L104">        this.maxDigits = fittingContainer(maxDigits);</span>
<span class="fc" id="L105">        this.ibuf = new int[this.maxDigits / PRIM_SLOTS];</span>

<span class="fc" id="L107">        this.precision = 1;   // Zero-value has precision 1</span>

<span class="fc" id="L109">        return;</span>
    }

    /**
     * Constructor for decimals with unsigned int32.
     */
    public BcdRegister(){
<span class="fc" id="L116">        this(MAX_COL_UINT32);</span>
<span class="fc" id="L117">        return;</span>
    }


    /**
     * Round-up to int array fitting size.
     *
     * @param digits decimal digits
     * @return rounded value
     */
    private static int fittingContainer(int digits){
        int result;

<span class="fc" id="L130">        result = digits;</span>
<span class="fc" id="L131">        result += PRIM_SLOTS - 1;</span>
<span class="fc" id="L132">        result /= PRIM_SLOTS;</span>
<span class="fc" id="L133">        result *= PRIM_SLOTS;</span>

<span class="fc" id="L135">        return result;</span>
    }


    /**
     * Clear all decimal digits to Zero.
     */
    public void clear(){
<span class="fc" id="L143">        int buflen = this.ibuf.length;</span>
<span class="fc bfc" id="L144" title="All 2 branches covered.">        for(int idx = 0; idx &lt; buflen; idx++){</span>
<span class="fc" id="L145">            this.ibuf[idx] = 0;</span>
        }

<span class="fc" id="L148">        this.precision = 1;</span>

<span class="fc" id="L150">        return;</span>
    }

    /**
     * Return total decimal digits holder width on register.
     *
     * &lt;p&gt;Digits holder width include leading zero spaces.
     *
     * @return digits holder width
     */
    public int getMaxDigits(){
<span class="fc" id="L161">        return this.maxDigits;</span>
    }

    /**
     * Get each decimal column value as int.
     *
     * @param digitPos digit column position. 0 is lowest column.
     * @return decimal value from 0 to 9
     * @throws IndexOutOfBoundsException invalid position.
     */
    public int getDigit(int digitPos) throws IndexOutOfBoundsException{
        int iIdx;
        int iMod;

<span class="fc" id="L175">        iIdx = digitPos &gt;&gt; PRIMIDX_SHIFT;  // Arithmetic shift to keep sign</span>
        //   = digitPos / 8;

<span class="fc" id="L178">        iMod = digitPos &amp; NBLIDX_MASK;</span>
        //   = digitPos % 8;

<span class="fc" id="L181">        int iVal = this.ibuf[iIdx];</span>
<span class="fc" id="L182">        int shiftWidth = iMod &lt;&lt; 2;</span>
        //             = iMod * 4;

<span class="fc" id="L185">        iVal &gt;&gt;&gt;= shiftWidth;</span>
<span class="fc" id="L186">        iVal &amp;= NIBBLE_MASK;</span>

<span class="fc" id="L188">        return iVal;</span>
    }

    /**
     * Store decimal result to int array.
     *
     * &lt;p&gt;Each decimal number stored to
     * each int array element. (non-packing BCD)
     *
     * &lt;p&gt;Leading zeros aren't transfered.
     * You need at least precision-size elements space to store.
     *
     * &lt;p&gt;Higher decimal number stored to lower array element.
     * If decimal result is '36', [0] is 3 and [1] is 6.
     *
     * @param dst destination array
     * @param offset start offset
     * @return Stored element size. ( = precision)
     * @throws IndexOutOfBoundsException too small array or negative offset.
     */
    public int toIntArray(int[] dst, int offset)
            throws IndexOutOfBoundsException{
<span class="fc" id="L210">        int digitsCt = getPrecision();</span>
<span class="fc" id="L211">        int addPos = digitsCt - 1;</span>

<span class="pc bpc" id="L213" title="1 of 2 branches missed.">        bufloop: for(int iVal : this.ibuf){</span>
<span class="fc bfc" id="L214" title="All 2 branches covered.">            for(int nblIdx = 0; nblIdx &lt; PRIM_SLOTS; nblIdx++){</span>
<span class="fc" id="L215">                int shPos = nblIdx &lt;&lt; 2;</span>
                //        = nblIdx * 4;

<span class="fc" id="L218">                dst[offset + addPos] = (iVal &gt;&gt;&gt; shPos) &amp; NIBBLE_MASK;</span>

<span class="fc bfc" id="L220" title="All 2 branches covered.">                if(addPos &lt;= 0) break bufloop;</span>

<span class="fc" id="L222">                addPos--;</span>
            }
        }

<span class="fc" id="L226">        return digitsCt;</span>
    }

    /**
     * Push 1bit LSB and double-dabble left shift.
     *
     * &lt;p&gt;If decimal overflow happens, just losing higher digits.
     *
     * @param carryOver LSB is 1 if true.
     * @return true if MSB overflow
     */
    public boolean pushLsb(boolean carryOver){
        int pushInt;
<span class="fc bfc" id="L239" title="All 2 branches covered.">        if(carryOver) pushInt = MSB_PRIMMASK;</span>
<span class="fc" id="L240">        else          pushInt = 0;</span>

<span class="fc" id="L242">        boolean result = pushLsb(pushInt);</span>

<span class="fc" id="L244">        return result;</span>
    }

    /**
     * Push 1bit LSB and double-dabble left shift.
     *
     * &lt;p&gt;If decimal overflow happens, just losing higher digits.
     *
     * @param carryOver LSB is 1 if non-zero.
     * @return true if MSB overflow
     */
    public boolean pushLsb(int carryOver){
<span class="fc" id="L256">        int lastMsbTest = carryOver;</span>

<span class="fc" id="L258">        int buflen = this.ibuf.length;</span>
<span class="fc bfc" id="L259" title="All 2 branches covered.">        for(int idx = 0; idx &lt; buflen; idx++){</span>
<span class="fc" id="L260">            int oldVal = this.ibuf[idx];</span>

<span class="fc" id="L262">            int fixVal = BcdUtils.toBiQuinary(oldVal);</span>
<span class="fc" id="L263">            int newVal = fixVal &lt;&lt; 1;</span>
<span class="fc bfc" id="L264" title="All 2 branches covered.">            if(lastMsbTest != 0) newVal |= LSB_PRIMMASK;</span>

<span class="fc" id="L266">            this.ibuf[idx] = newVal;</span>
<span class="fc" id="L267">            lastMsbTest = fixVal &amp; MSB_PRIMMASK;</span>
        }

<span class="fc" id="L270">        this.precision = -1;   // unknown precision</span>
<span class="fc bfc" id="L271" title="All 2 branches covered.">        boolean result =</span>
                lastMsbTest != 0;

<span class="fc" id="L274">        return result;</span>
    }

    /**
     * Return decimal precision.
     *
     * &lt;p&gt;Precision is a valid decimal digits width without leading zero.
     *
     * &lt;p&gt;Precision is less or equal than max digits size always.
     *
     * &lt;p&gt;Precision of '40560' is 5.
     *
     * &lt;p&gt;Precision of '0' is 1.
     *
     * @return decimal precision.
     */
    public int getPrecision(){
<span class="fc bfc" id="L291" title="All 2 branches covered.">        if(this.precision &gt; 0){</span>
<span class="fc" id="L292">            return this.precision;</span>
        }

<span class="fc" id="L295">        int result = calcPrecision();</span>
<span class="fc bfc" id="L296" title="All 2 branches covered.">        if(result == 0) result = 1;</span>

<span class="fc" id="L298">        this.precision = result;</span>

<span class="fc" id="L300">        return result;</span>
    }

    /**
     * Calculate decimal precision.
     *
     * &lt;p&gt;Precision is valid decimal digits without leading zero.
     *
     * &lt;p&gt;Precision of 40560 is 5.
     *
     * &lt;p&gt;Precision of 0 is 1 but return 0.
     *
     * @return decimal precision.
     */
    private int calcPrecision(){
<span class="fc" id="L315">        int result = this.maxDigits;</span>

<span class="fc" id="L317">        int idxMax = this.ibuf.length - 1;</span>
<span class="fc bfc" id="L318" title="All 2 branches covered.">        for(int iIdx = idxMax; iIdx &gt;= 0; iIdx--){</span>
<span class="fc" id="L319">            int iVal = this.ibuf[iIdx];</span>

<span class="fc" id="L321">            int clz = BcdUtils.clzNibble(iVal);</span>
<span class="fc" id="L322">            result -= clz;</span>

<span class="fc bfc" id="L324" title="All 2 branches covered.">            if(clz != PRIM_SLOTS){</span>
<span class="fc" id="L325">                break;</span>
            }
        }

<span class="fc" id="L329">        return result;</span>
    }

    /**
     * {@inheritDoc}
     * Return text for debug usage.
     *
     * @return {@inheritDoc}
     */
    @Override
    public String toString(){
<span class="fc" id="L340">        StringBuilder sb = new StringBuilder();</span>

<span class="fc" id="L342">        boolean dumped = false;</span>
<span class="fc" id="L343">        int validCols = getPrecision();</span>
<span class="fc bfc" id="L344" title="All 2 branches covered.">        for(int colCt = validCols - 1; colCt &gt;= 0; colCt--){</span>
<span class="fc" id="L345">            int iIdx   = colCt &gt;&gt;&gt; PRIMIDX_SHIFT;</span>
            //         = colCt / 8;
<span class="fc" id="L347">            int nblIdx = colCt &amp; NBLIDX_MASK;</span>
            //         = colCt % 8;

<span class="fc" id="L350">            int iVal = this.ibuf[iIdx];</span>
<span class="fc" id="L351">            int shiftWidth = nblIdx &lt;&lt; 2;</span>
            //             = nblIdx * 4;

<span class="fc" id="L354">            iVal &gt;&gt;&gt;= shiftWidth;</span>
<span class="fc" id="L355">            int nibble = iVal &amp; NIBBLE_MASK;</span>

<span class="fc bfc" id="L357" title="All 2 branches covered.">            if(dumped){</span>
<span class="fc" id="L358">                sb.append(SP);</span>
            }

<span class="fc" id="L361">            dumpNibble(sb, nibble);</span>
<span class="fc" id="L362">            dumped = true;</span>
        }

<span class="fc" id="L365">        String result = sb.toString();</span>
<span class="fc" id="L366">        return result;</span>
    }

    /**
     * Dump nibble.
     *
     * &lt;p&gt;nibble 5 -&gt; 0101[5]
     *
     * @param sb output
     * @param nibble BCD nibble value. (0 =&amp;lt; nibble &amp;lt; 10)
     */
    private void dumpNibble(StringBuilder sb, int nibble){
<span class="fc" id="L378">        int b3 = (nibble &gt;&gt; 3) &amp; LSB_PRIMMASK;</span>
<span class="fc" id="L379">        int b2 = (nibble &gt;&gt; 2) &amp; LSB_PRIMMASK;</span>
<span class="fc" id="L380">        int b1 = (nibble &gt;&gt; 1) &amp; LSB_PRIMMASK;</span>
<span class="fc" id="L381">        int b0 =  nibble       &amp; LSB_PRIMMASK;</span>

<span class="fc" id="L383">        char c3 = HEXCH_TBL[b3];</span>
<span class="fc" id="L384">        char c2 = HEXCH_TBL[b2];</span>
<span class="fc" id="L385">        char c1 = HEXCH_TBL[b1];</span>
<span class="fc" id="L386">        char c0 = HEXCH_TBL[b0];</span>

<span class="fc" id="L388">        sb.append(c3);</span>
<span class="fc" id="L389">        sb.append(c2);</span>
<span class="fc" id="L390">        sb.append(c1);</span>
<span class="fc" id="L391">        sb.append(c0);</span>

<span class="pc bpc" id="L393" title="2 of 4 branches missed.">        assert nibble &lt; 16;</span>
<span class="fc" id="L394">        char decCh = HEXCH_TBL[nibble];</span>

<span class="fc" id="L396">        sb.append(CH_OPEN);</span>
<span class="fc" id="L397">        sb.append(decCh);</span>
<span class="fc" id="L398">        sb.append(CH_CLOSE);</span>

<span class="fc" id="L400">        return;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>